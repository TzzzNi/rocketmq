> All the modified sentences are in bold style. 

## Core Concept
![cmd-markdown-logo](https://rocketmq.apache.org/assets/images/rmq-model.png)

According to the model above, **we can further explore the following  topics about the design of messaging system**:

- Consumer Concurrency
- Consumer Hot Issues
- Consumer Load Balance
- Message Router
- Connection Multiplex
- Canary Deployments

## Producer

A producer sends messages generated by the business application to brokers. RocketMQ provides **multiple patterns of massage exchanging: synchronous, asynchronous and one-way**.

### Producer Group

A producer group is consist of the producers of same role. **Different producer instances among the same group can commit or roll back a transaction via brokers in case the original producer may crash after the transaction starts**.

**Warning:** Considering a producer is sufficiently powerful at sending messages, only one instance can be processed to avoid unnecessary initialization of producer instances per group.

## Consumer

A Consumer pulls messages from brokers and feeds them into application. In perspective of user application, RocketMQ provides two types of consumers:

### PullConsumer

Pull consumer actively pulls messages from brokers. Once batches of messages are pulled, user application will initiate consuming process.

### PushConsumer

Push consumer, on the other hand, **encapsulates message pulling, consuming progress and other internal work, leaving one callback interface which can be executed once message arrives**.

### Consumer Group

Similar to producer group, consumer group contains consumers of exactly same role.
**Consumer Group can realize load-balance and fault-tolerance which is quite handy for message consuming**.

**Warning:** Consumer instances among one  consumer group **must** have exactly the same topic subscription(s).

## Topic
Topic is a category in which producers deliver messages and consumers pull messages. Topics have very loose relationship with producers and consumers. Specifically, a topic may have zero, one or multiple producers that send messages to it; conversely, a producer can send messages to different topics. In consumerâ€™s perspective, a topic may be subscribed by zero, one or multiple consumers. And a consumer group may subscribe to one or more topics as long as its instances keep their subscription(s) consistent.


## Message
Message is the information to be delivered. A message must have a topic which can be interpreted as your mailing address. A message may also have an optional tag or extra key-value pairs. **For example, you may set a key-value pair for your massage to look up via broker sever for further diagnosis and development**.

### Message Queue

A topic can be partitioned into one or more sub-topics as message queues.

### Tag

Tag, aka sub-topic, provides extra flexibility to users. For instance, messages with different purposes from the same business module may have the same topic and different tags. Besides, tag can keep your code clean and coherent, and facilitate RocketMQ query system.


### Broker

Broker is a major component of the RocketMQ system. It receives and stores messages from producers, and handles pull requests from consumers. It also stores meta data related to massages, including consumer groups, consuming progress offsets and topic / queue info.



## Name Server
Name server serves as the routing information provider for producer/consumer to read/write topics via corresponding broker list.


## Message Model
- Clustering
- Broadcasting

## Message Order

When DefaultMQPushConsumer is employed, you may decide to consume messages orderly or concurrently.

- Orderly

It means messages are consumed in the **same order as they are sent** by producers for each message queue. While the global order is mandatory, you have to make sure the topic has only one message queue.

**Warning:** If the consuming order is specified, the maximum concurrency is the number of message queues subscribed by the consumer group.

- Concurrently

Under such circumstance, the maximum concurrency of message consuming is only limited by thread pool specified for each consumer client.


**Warning:** Message order is no longer guaranteed in this mode.
